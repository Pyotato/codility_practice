# Ladder
* [Report summary Link : Sol](https://app.codility.com/demo/results/trainingKJUZG3-6XK/)

# Task Details
> 사디리 꼭대기에 도달할 수 있는 방법의 가지 수를 구하라.
# Task description
> * 1부터 N개의 다리로 이루어진 사다리가 있다. 한 번 다리를 오를 때 1개 혹은 2개의 다리를 오를 수 있다.
>     * 첫 발로는 1또는 2번째 다리에 오를 수 있다.
>     * K번째 다리에 있다면 K + 1 또는 K + 2로 이동가능하다.
>     * 최종적으로 N번째 다리에 도달해야한다.

예를 들어 N = 4일 때 오를 수 있는 방법의 가지 수는 5가지 이다:
* 다리 : 1, 1, 1 ,1 로 건너기
* 다리 : 1, 1, 2 로 건너기
* 다리 : 1, 2, 1  로 건너기
* 다리 : 2, 1, 1 로 건너기
* 다리 : 2, 2 로 건너기
  
예를 들어 N = 5일 때 오를 수 있는 방법의 가지 수는 8가지 이다:
* 다리 : 1, 1, 1 ,1 , 1 로 건너기
* 다리 : 1, 1, 1, 2 로 건너기
* 다리 : 1, 1, 2, 1  로 건너기
* 다리 : 1, 2, 1, 1  로 건너기
* 다리 : 1, 2, 2  로 건너기
* 다리 : 2, 1, 1, 1  로 건너기
* 다리 : 2, 1, 2 로 건너기
* 다리 : 2, 2, 1 로 건너기

> 사다리를 탈 수 있는 경우의 수는 매우 클 수 있으므로 정수 P가 주어졌을 때 2<sup>P</sup>으로 경우의 수를 나눈 나머지를 구하라.

* 빈 배열이 아닌 배열 A와 B, 정수 L이 주어졌을 때, I위치에서 A[I]로 오를 수 있는 경우의 가지수를 2<sup>P</sup>으로 나눈 나머지를 각각 L개의 원소로 나타낸 배열을 구하라. 

예를 들면 L=5일 때,
*    A[0] = 4   B[0] = 3
*    A[1] = 4   B[1] = 2
*    A[2] = 5   B[2] = 4
*    A[3] = 5   B[3] = 3
*    A[4] = 1   B[4] = 1
  
이고  [5, 1, 8, 0, 1] 을 리턴해야한다.

> * 아래의 가정들을 만족하는 **효율적인** 알고리즘을 작성해라.
>     * L은  [1..50,000]사이의 정수다.
>     * 배열 A의 각 원소는 [1...L] 사이의 정수다.
>     * 배열 B의 각 원소는 [1...30] 사이의 정수다.

# Logic
| Index | 0 | 1 | 2 | 3 | 4  |
| :--: | :--: |:--: | :--: |:--: | :--: |
| A[Index] | 4 | 4 | 5 | 5 | 1 |
| B[Index] | 3 | 2 | 4 | 3 | 1 |
| A[Index]를 오를 수 있는 가지 수 | 5 | 5 | 8 | 8 | 1 |
| 2<sup>B[Index]</sup> | 8 | 4 | 16 | 8 | 2 |
| (A[Index]를 오를 수 있는 가지 수)%2<sup>B[Index]</sup> | 5 | 1 | 8 | 0| 1 |
* 사다리를 한번에 오를 때는 한개 또는 두개의 다리만 올라갈 수 있다.
* 0 = 0 가지 방법
* 1 = 1가지 방법 = 1
* 2 = 1+1, 2 두가지 방법 = 2 = 1+1
* 3 = 1+(1+1), 1+(2), (2)+1 = 3 = 1+2
* 4 = (1+(1+1))+1, (1+1))+2, 2+(1+1)), (1+2+1), 2+2 = 5= 3+2
* 5 = 1+((1+(1+1))+1), 1+((1+1))+2),((1+1))+2)+1,1+(2+(1+1))),(2+(1+1)))+1, 1+(1+2+1),(1+2+1)+1, (2+2)+1 = 5+3
* 즉 피보나치 수열을 이루기 때문에 길이만큼 저장해놓고 <sup>B[Index]</sup>로 나눈 나머지 값을 배열의 인덱스로 할당하고 저장하면 된다.

# Solution 
* 사용언어 : javascript
* 점수 : 100
* 시간 복잡도 : **O(L)** 또는
* 풀이
```javascript
function solution(A, B) {
    const len = A.length;
    const ans = new Array(len).fill(0);

    const fib = (num) =>{
        const max = Math.pow(2,30);
        const arr = [0,1,1];
        let curr = 2;
        while(curr<=num){
            curr++;
            next = arr[curr-1]+arr[curr-2] % max;
           arr.push(next);
        }
        arr.shift();
        return arr;
    };

    const fibArr = fib(len+1);

    for(let i=0; i<len;i++){
        ans[i] = fibArr[A[i]] % Math.pow(2,B[i]);
    }
    
    return ans;
}
```
