# TieRopes
* [Report summary Link](https://app.codility.com/demo/results/training5UV2KD-98X/)
# Task Details
> 연속된 밧줄들을 이은 길이가 k보다 크거나 같게 되는 밧줄 최대 밧줄 개수를 구하라.
# Task description
> * 0에서 N-1까지 숫자가 맥진 N개의 밧줄의 길이를 원소로 한 배열 A가 일렬로 바닥에 놓여있다. 각 I (O<=I<N)에 관해 A[I]는 I번째 밧줄의 길이다.
> * 두 밧줄 I와 I+1은 인접해 있다고 하자. 두 인접한 밧줄은 서로 매듭을 묶어서 전체 길이가 두 밧줄의 길이의 합이 된다. 이어진 밧줄은 또 인접한 다른 밧줄과 이어질 수 있다.
> * 예를 들어 정수 K가 주어졌을 때, 목표는 이은 밧줄의 개수가 최대가 되도록하는 K보다 크거나 적은 수를 구하는 것이다.

예를 들어 K = 4이고 A 배열이 주어졌을 때,
| A[index] | Rope length |
| :--: | :--: |
| A[0] | 1| 
|  A[1] | 2| 
| A[2]  | 3 | 
| A[3] | 4| 
| A[4]  | 1 | 
| A[5] | 1 | 
| A[6] | 3 | 
밧줄은 아래와 같이 놓여있다.

![image](https://github.com/Pyotato/codility_practice/assets/102423086/d7f36866-4286-47e2-a65a-56963e751ac0)


> 우리는 다음과 같이 밧줄을 이을 수 있다:
> * 밧줄 1과 2를 이어 A[1]+A[2] = 5
> * 밧줄 4와 5, 6을 이어 A[4]+A[5]+A[6] = 5

> K=4보다 크거나 같은 밧줄의 길이는 밧줄을 3개 이었을 때다. 4개의 밧줄로는 이를 만족하는 경우가 없다.

> `function solution(K,A)`에 관해, 정수 K와 빈 배열이 아닌 N개의 원소를 가진 배열 A가 K보다 크거나 같은 밧줄길이가 되도록하는 최대 밧줄 개수를 구해라.

아래의 가정들을 만족하는 **효율적인** 알고리즘을 작성해라.
> * N은 [1..100,000] 사이의 정수다.
> * K는 [1..1,000,000,000] 사이의 정수다.
> * A의 각 원소는 [1..1,000,000,000] 사이의 정수다. 

# Logic
* 밧줄의 길이가 k보다 작으면 다음 밧줄과 잇는 것 반복한다.
* 반대로 K보다 크거나 같다면 만들 수 있는 밧줄의 경우의 수를 더해주고 밧줄 길이는 다시 0부터 고려한다.
* 예를 들어 밧줄0은 K보다 작으므로 과 밧줄1를 이으면 길이가 3이다. 아직 K보다 작으므로 이를 밧줄2와 이으면 6이 되므로 1개의 경우다.
* 밧줄3은 K=4와 같으므로 경우+1해줘서 2가 된다.
* 밧줄4는 1이므로 밧줄5와 이어주면 2가 되고, 이 또한 아직 K보다 작으므로 밧줄6을 이어주면 5가 되고 K보다 크므로 경우+1을 해줘서 답은 3이 된다.
* N을 for문으로 N번 만큼 돌기 때문에 시간 복잡도는 <i>O</i>(N)이 된다.

# Solution 
* 사용언어 : javascript
* 점수 : 100
* 시간 복잡도 : **O(n)**
* 풀이
```javascript
function solution(K, A) {
    let cnt = 0;
    let prv = 0;
    for (let i = 0; i<A.length; i++){
        if((prv + A[i]) >= K){
            cnt++;
            prv = 0;
            continue;
        } 
        prv+=A[i];
    }
    return cnt;
}
```
