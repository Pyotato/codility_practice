# MinAbsSumOfTwo
* [Report summary Link : Sol](https://app.codility.com/demo/results/training437UXH-2TK/)

# Task Details
>  배열 원소의 합의 절대값의 최소값을 구하라.
# Task description
> * 빈 배열이 아닌 A는 N개의 숫자를 원소로 한다. (P,Q)는 0 <= P <= Q < N을 만족하고 |A[P] + A[Q]|인 값이다. 

예를 들어 A 배열이 주어졌을 때,
| A |  |
| :--: | :--: |
| A[0] | 1 | 
| A[1] | 4 | 
| A[2] | -3 | 


> 위의 합의 절대값의 최소는 1이다. 위의 배열에서 나올 수 있는 짝은 (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)이다. 
* (0, 0) 의 합의 절대값은 A[0] + A[0] = |1 + 1| = 2.
* (0, 1) 의 합의 절대값은 A[0] + A[1] = |1 + 4| = 5.
* (0, 2) 의 합의 절대값은 A[0] + A[2] = |1 + (−3)| = 2.
* (1, 1) 의 합의 절대값은 A[1] + A[1] = |4 + 4| = 8.
* (1, 2) 의 합의 절대값은 A[1] + A[2] = |4 + (−3)| = 1.
* (2, 2) 의 합의 절대값은 A[2] + A[2] = |(−3) + (−3)| = 6.

마찬가지로 배열A가 아래와 같을 때, 

| A |  |
| :--: | :--: |
| A[0] | -8 | 
| A[1] | 4 | 
| A[2] | 5 | 
| A[3] | -10| 
| A[4] | 3 | 

답은 |(−8) + 5| = 3을 리턴해야한다.
> * 아래의 가정들을 만족하는 **효율적인** 알고리즘을 작성해라.
>     * N은 [1..100,000]사이의 정수다.
>     * 배열 A의 각 원소는 [−1,000,000,000..1,000,000,000] 사이의 정수다.

# Logic

| A[index] | -3 |1  | 4 | sum | min|
| :--: | :--: |:--: |:--: |:--: |:--: |
| caterpillar |T  | |H|(-3)+(4) = 1| 1 |
| caterpillar | T |H||(-3)+(1) = -2| 1 |
| caterpillar |  |T-H||(1)+(1) = 2| 2 |

| A[index] | -10 | -8  | 3 | 4 |5 | sum | min|
| :--: | :--: |:--: |:--: |:--: |:--: |:--: |:--: |
| caterpillar | T |:--: |:--: |:--: | H |(-10)+(5) = -5 |5|
| caterpillar |  |T |:--: |:--: | H |(-8)+(5) = -3 |3|
| caterpillar |  | |T |:--: | H |(3)+(5) = 8 |3|
| caterpillar |  | |T |H |  |(3)+(4) = 7 |3|
| caterpillar |  | |T-H | |  |(3)+(3) = 6 |3|
* 애벌레 방식을 활용하기 위해서 오름차순으로 정렬한다. (조건에 따라 머리나 꼬리를 이동시켜줘서 끝에 도달해야하기 때문.)
* 위의 문제에서는 합을 구하는 것이므로, 중복된 수를 먼저 제거해줘서 반복문을 덜 돌 수 있도록 해준다.
* 오른차순으로 정렬하고 애벌레의 머리가 H(배열의 끝), T가 꼬리(배열의 시작)이라고 할 때 만약 합이 음수라면 T가 음수고 T의 절대값이 더 크다는 뜻이다.
* 반면 합이 양수라면 두 원소 모두 양수라는 뜻이다.
* 원소 중 하나가 음수라면 둘의 합이 더 작은 값이 있을 수 있으므로 꼬리를 하나 앞으로 해서 탐색한다.
* 꼬리와 머리가 서로 같은 위치에 존재하면 탐색 종료. 정렬을 위해 O(N)만큼 시간이 걸리고, 양쪽끝을 기준의 quicksort를 하기 때문에 시간 복잡도는 O(N * log(N))이된다.  

# Solution : 
* 사용언어 : javascript
* 점수 : 100
* 시간 복잡도 : **O(N * log(N))** 
* 풀이
```javascript
function solution(A) {
    let set = new Set(A);
    set = [...set];
    let min = Infinity;
    let left = 0, right = set.length-1;
    set.sort((a,b)=> a-b);
    
    while(left <= right){
        let sum = set[left]+set[right];
        let abs = Math.abs(sum);

        if(abs<min) min = abs;
        if(sum<0) left++;
        else right--;
    }
        return min;
}
```
