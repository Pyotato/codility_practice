# MinMaxDivision
* [Report summary Link : Sol](https://app.codility.com/demo/results/trainingWDXGG6-4SJ/)

# Task Details
> 배열A를 K개의 블록으로 나눠서 블록들의 합 중 최대값이 최소가 되도록 하는 값을 구하라.
# Task description
> * 정수 K,M과 빈 배열이 아닌 N개의 정수를 갖고 있는 배열 A가 주어진다. 각 배열의 원소는 M보다 작다.
> * 이 배열을 연속된 원소들을 갖는 K개의 블록으로 나눠야한다. 각 블록의 크기는 0과 N 사이의 정수다. 각 원소는 반드시 어느 블록에 속해야 한다.
> * 블록에서 X에서 Y까지의 합은 A[X] + A[X + 1] + ... + A[Y]이다. 비어있는 블록의 합은 0이다.
> * <i>large sum</i>은 블록의 최대 합의 값이다.

예를 들어 K = 3, M = 5 이고 A 배열이 주어졌을 때,
| A |  |
| :--: | :--: |
| A[0] | 2 | 
| A[1] | 1 | 
| A[2] | 5 | 
| A[3] | 1 | 
| A[4] | 2 | 
| A[5] | 2 | 
| A[6] | 2 | 

> 위의 배열은 다음과 같은 블록들로 나뉠 수 있다.
> * [2, 1, 5, 1, 2, 2, 2], [], [] 의 <i>large sum</i>은 15
> * [2], [1, 5, 1, 2], [2, 2] 의 <i>large sum</i>은  9
> * [2, 1, 5], [], [1, 2, 2, 2] 의 <i>large sum</i>은 8
> * [2, 1], [5, 1], [2, 2, 2] 의 <i>large sum</i>은 6.

목표는 <i>large sum</i>값들 중 최소값을 구하는 것이다. 위와 같은 경우 답은 6이다. 

> * 아래의 가정들을 만족하는 **효율적인** 알고리즘을 작성해라.
>     * N과 K는 [1..100,000]사이의 정수다.
>     * M은 [0..10,000]사이의 정수다.
>     * 배열 A의 각 원소는 [0...,M] 사이의 정수다.

# Logic

| A[index] | 2 | 1 | 5 | 1 | 2 | 2 | 2|
| :--: | :--: |:--: | :--: |:--: | :--: |:--: |:--: |
| sum | 2 | 3 | 8 | 9 | 11 |13 |15 |
| max | 2 | 2 | 5 | 5 |5 |5 |5 |

| A[index] | `5` | 6 | 7 | `8` | `9` | 10| `11` | 12| `13` | 14| `15` |
| :--: | :--: |:--: | :--: |:--: | :--: |:--: |:--: |:--: |:--: |:--: |:--: |
| range | 5 | 6 | 7 | 8 | 9 |10 |  | | | | |
| range | 5 | 6 |7  | |  | |  | | | | |
| range | 5 | 6 |  | |  | |  | | | | |
| range |  | 6 |  | |  | |  | | | | |

* 시작(start)을 가장 큰 값으로 두고 모든 원소의 합을 끝으로 둘 때 (end)
* start = 5, end = 15 사이의 range가 주어진다.
* K (나누어야하는 블록의 개수)보다 블록의 합이 최대가 되게 하는 블록의 개수가 클 경우 mid을 초과한 원소들을 버린다.
* 반대로는 mid 미만의 원소들을 버리고 start>end일 경우 종료한다.
* 즉 중간값은 (5 + 15)/2 = 10이고 부분의 합이 10보다 작은 값들이 있으므로 10보다 큰 값들은 버린다.
* 중간값은 (5 + 10)/2 = 7.5 => 7보다 합이 최소인 값이 존재하므로 7 보다 큰 원소들은 버린다.
* 중간값은 (5 + 7)/2 = 6 일 경우 시작과 끝값이 역전되므르 6을 리턴한다. 

# Solution 
* 사용언어 : javascript
* 점수 : 100
* 시간 복잡도 : **O(N*log(N+M))** 
* 풀이
```javascript
function solution(K, M, A) {
    let max = -1;
    let sum = 0;
    for (const a of A) {
        if (a > max) {
            max = a;
        }
        sum += a;
    }

    let start = max;
    end = sum;
    while (start <= end) {
        let mid = Math.floor((start + end)/2);
        if (check(A, mid) > K) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return start;
}

function check(A, max) {
    let sum = 0, k = 1;
    for (const a of A) {
        sum += a;
        if (sum > max) {
            k++;
            sum = a;
        }
    }
    return k;
}
```
